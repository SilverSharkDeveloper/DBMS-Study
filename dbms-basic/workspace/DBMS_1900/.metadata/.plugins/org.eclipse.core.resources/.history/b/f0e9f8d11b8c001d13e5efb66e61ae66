--natural join을 사용할 때의 문제점 : 공유하는 컬럼이 여러개일 경우 원하는 데이터가 나오지 않을 수 있다.
--공유하는 컬럼이 한개인경우 사용하는게 좋다.

SELECT * FROM EMPLOYEES e ;
SELECT * FROM DEPARTMENTS ;

SELECT * 
FROM EMPLOYEES e NATURAL JOIN DEPARTMENTS d ;

--부서이름과 부서 매니저 이름 뽑기
SELECT D.DEPARTMENT_NAME , E.FIRST_NAME 
FROM DEPARTMENTS d JOIN EMPLOYEES e 
ON D.MANAGER_ID = E.EMPLOYEE_ID 

SELECT * FROM LOCATIONS l ;

SELECT D.DEPARTMENT_NAME ,L.CITY 
FROM DEPARTMENTS d RIGHT OUTER JOIN LOCATIONS l 
ON D.LOCATION_ID = L.LOCATION_ID ;

SELECT *
FROM DEPARTMENTS d INNER JOIN EMPLOYEES e 
ON D.MANAGER_ID = E.EMPLOYEE_ID ;

SELECT *
FROM DEPARTMENTS d  LEFT OUTER JOIN EMPLOYEES e
ON D.MANAGER_ID = E.EMPLOYEE_ID ;

SELECT * FROM EMPLOYEES e ;
SELECT * FROM DEPARTMENTS d ;

--오라클 문법 내부조인
SELECT D.DEPARTMENT_NAME , L.CITY 
FROM DEPARTMENTS d , LOCATIONS l 
WHERE D.LOCATION_ID = L.LOCATION_ID ;
--오라클 문법 외부조인

--(+)의미 ->데이터가 부족하므로 추가해준다는 의미 -> (+)가 붙지 않은 쪽을 전체 조회하겠다라는 의미
--(+)가 붙지 않은쪽 OUTER JOIN이 결과가 된다.

--RIGHT OUTER JOIN -> WHERE절 왼쪽 테이블에 (+)
SELECT D.DEPARTMENT_ID ,L.CITY 
FROM DEPARTMENTS d ,LOCATIONS l 
WHERE D.LOCATION_ID(+) = L.LOCATION_ID ;
--LEFT OUTER JOIN -> WHERE절 오른쪽 테이블에 (+)
SELECT D.DEPARTMENT_ID ,L.CITY 
FROM DEPARTMENTS d ,LOCATIONS l 
WHERE D.LOCATION_ID = L.LOCATION_ID(+) ;
--FULL OUTER JOIN 사용 불가

--크로스 조인
SELECT *
FROM DEPARTMENTS d CROSS JOIN EMPLOYEES;

--USING 조건
SELECT *
FROM DEPARTMENTS d JOIN LOCATIONS l 
USING(LOCATION_ID);

SELECT DEPARTMENT_ID
FROM EMPLOYEES e 
UNION
SELECT DEPARTMENT_ID 
FROM DEPARTMENTS d ;

SELECT DEPARTMENT_ID
FROM EMPLOYEES e 
UNION ALL
SELECT DEPARTMENT_ID 
FROM DEPARTMENTS d ;

SELECT DEPARTMENT_ID
FROM EMPLOYEES e 
INTERSECT
SELECT DEPARTMENT_ID 
FROM DEPARTMENTS d ;

SELECT DEPARTMENT_ID 
FROM DEPARTMENTS d 
MINUS
SELECT DEPARTMENT_ID
FROM EMPLOYEES e ;

SELECT *FROM EMPLOYEES;
--서브쿼리
--단일행 서브쿼리
SELECT FIRST_NAME ,SALARY 
FROM EMPLOYEES e 
WHERE SALARY = (SELECT SALARY  FROM EMPLOYEES WHERE FIRST_NAME = 'Janette');

--다중행 서브쿼리
SELECT FIRST_NAME ,SALARY 
FROM EMPLOYEES e 
WHERE SALARY IN(SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

SELECT FIRST_NAME ,SALARY 
FROM EMPLOYEES e 
WHERE SALARY > ANY(SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

SELECT FIRST_NAME ,SALARY 
FROM EMPLOYEES e 
WHERE SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

--EXISTS
--부서ID에 직원이 존재하는 부서의 부서이름 가져오기
SELECT DEPARTMENT_NAME 
FROM DEPARTMENTS d 
WHERE EXISTS(
		SELECT 1
		FROM EMPLOYEES e 
		WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID);

--IN으로 표현이 가능하지만 속도가 EXISTS가 더빠르다
	
SELECT DEPARTMENT_NAME 
FROM DEPARTMENTS d 
WHERE DEPARTMENT_ID IN(SELECT DEPARTMENT_ID FROM EMPLOYEES e);



SELECT  *
FROM DEPARTMENTS d  INNER JOIN LOCATIONS l 
USING(LOCATION_ID);

SELECT DEPARTMENT_NAME, CITY
FROM (SELECT  *
 			FROM DEPARTMENTS d  INNER JOIN LOCATIONS l 
			USING(LOCATION_ID)
			);
			
		
SELECT DEPARTMENT_NAME, 
	CASE WHEN EXISTS(SELECT 1 FROM EMPLOYEES e 
										WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID)
			THEN '근무하는 직원 존재'
			ELSE'근무하는 직원 없음'
			END 비고
FROM DEPARTMENTS d ;

--평균 봉급보다 많이 받는직원 이름과 봉급 조회
SELECT FIRST_NAME ,SALARY 
FROM EMPLOYEES e 
WHERE SALARY> (SELECT AVG(SALARY)FROM EMPLOYEES);

--다중 컬럼 서브 쿼리
--오라클에서만 사용가능

SELECT DEPARTMENT_ID , MIN(SALARY)
FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID; 

SELECT DEPARTMENT_ID ,FIRST_NAME ,SALARY 
FROM EMPLOYEES e 
WHERE (DEPARTMENT_ID ,SALARY) IN	(SELECT DEPARTMENT_ID , MIN(SALARY)
FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID);

--계층형 질의
SELECT FIRST_NAME 
FROM EMPLOYEES e 
START WITH FIRST_NAME = 'Karen'
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID  ;

CREATE TABLE 무한상사(
	직원이름 VARCHAR2(100),
	직급 VARCHAR2(100),
	상사이름 VARCHAR2(100),
	CONSTRAINT PK PRIMARY KEY(직원이름),
	CONSTRAINT A_FK FOREIGN KEY (상사이름) REFERENCES 무한상사(직원이름)
);

INSERT INTO 무한상사
VALUES('김철수', '사장', NULL);
INSERT INTO 무한상사
VALUES('유재석', '부장', '김철수');
INSERT INTO 무한상사
VALUES('노홍철', '과장', '유재석');
INSERT INTO 무한상사
VALUES('정준하', '과장', '유재석');
INSERT INTO 무한상사
VALUES('정현돈', '대리', '정준하');
INSERT INTO 무한상사
VALUES('하하', '사원', '정현돈');
INSERT INTO 무한상사
VALUES('박명수', '사원', '정현돈');


SELECT * FROM 무한상사;

SELECT 직원이름
FROM 무한상사
START WITH 직원이름 = '정현돈'
CONNECT BY PRIOR 직원이름 = 상사이름;

--최상위 데이터 부터 아랫방향으로 찾기
SELECT 직원이름
FROM 무한상사
START WITH 상사이름 IS NULL
CONNECT BY PRIOR 직원이름 = 상사이름
ORDER SIBLINGS BY 직원이름 DESC;

