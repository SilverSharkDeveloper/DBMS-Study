연산자
	-피연산자가 어떤 타입인지
	-연산 결과가 어떻게 나오는지
	-연산 결과가 어떤 타입인지
	ex)날짜 + 숫자*(날짜-날짜) + 숫자
	->날짜-날짜 = 숫자
	->숫자*숫자 = 숫자
	->날짜 + 숫자 = 날짜
	->날짜 +숫자 = 날짜
	->최종결과 = 날짜



관계 연산자
	조건을 설정하기 위해 사용한다. ->행을 골라낼때 사용
	피 연산자의 종류는 상관없다.
	두 개의 피연산자 타입이 서로 일치해야 한다.
	a>b -> a가 b보다 큰 조건에만 데이터를 가져온다.
	a<b -> a가 b보다 작은 조건에만 데이터를 가져온다.
	a>=b -> a가 b보다 크거나 같은 조건
	a<=b	-> a가 b보다 작거나 같은 조건
	a=b ->a가 b랑 같은 조건
	a<>b a가 b랑 다른조건(표준)
	a!=b a가 b랑 다른조건

**날짜라는건 인간만이 아는 추상적인 존재 ->표현할 수 없다.
	날짜를 표현하고 싶다면 -> 문자를 날짜로 형 변환 해야한다. 
	->TO_DATE(문자, 방식)이라는 함수를 사용해야한다.
	->그냥 문자로 표현해도 컴퓨터가 알아서 자동 형변환을 해준다.


WHERE절 : 행을 골라내는 방법
	SELECT 컬럼, 컬럼,컬럼,.....FROM 테이블 WHERE 조건;

**문자의 비교**
 숫자와 날짜는 직관적으로 비교하기 쉽다. ->문자는 직관적으로 비교하기가 어렵다
--문자의 크기는 컴퓨터 상의 문자에 해당하는 숫자 크기로 계산
--각각에 문자에 해당하는 숫자값을 정리해놓은 규칙을 아스키 코드라고한다. 'a'는 97, 'A'는 65
--사전순서라고 생각하면 편하다.
--ORDER BY 문자형태의 컬럼을 쓰면 사전순서로 정열된다. DESC쓸경우 사전 역순서로 정렬되는 이유도 문자를 아스키코드상의 숫자로 컴퓨터가 계산하기 때문이다.

ex) SELECT salary, first_name FROM employees WHERE first_name>'M';
->첫글자가 M보다 큰 행만 출력한다.
->M으로 시작하는 이름도 'M'보단 크기때문에 출력한다.
->만약 이름이 M한글자라면 M보다 큰값만 출력하기때문에 출력하지 못한다.

SQL 연산자
	조건을 설정할 때 사용하는 연산자
	--a BETWEEN b AND c -> a가 b와 c사이인 조건 **b와 c는 포함이된다**
	--a IN(b,c,d,e,....) -> a가 b랑 같거나 , c랑 같거나, d랑같거나.... 을 만족하는 조건
	--a LIKE 패턴 -> a가 패턴을 만족하는 조건
		-피연산자가 문자 타입일때 주로 사용
	
	NULL : 값이 없음을 나타내는 값	
	--IS NULL ->NULL 값이 들어있는 행을 골라내기 위한 조건
	--IS NOT NULL -> NULL 값이 들어있지 않은 행 골라내기 위한 조건
		** = NULL 또는 !=NULL로 값을 가져올 수 없다.**
	
	서브쿼리 사용할 때 사용하는 연산자
	--a 관계연산자 ANY (b,c,d,e,....) -> a관계연산자 b or c or d....어느하나라도 만족하는조건
	--a 관계연산자 ALL (b,c,d,e,...) -> a 관계연산자b and c and d .... 모두 만족하는 조건
	--EXISTS () ->존재하는 조건
	--NOT EXISTS() ->존재하지 않는 조건

논리연산자
	여러개의 조건을 동시에 적용하기 위해서 사용한다.
	피연산자는 조건이다.

	조건1 AND 조건2 ->조건1,조건2 모두만족하는 조건
	조건1 OR 조건2 -> 조건1 또는 조건2를 만족하는 조건
	NOT 조건 -> 조건을 만족하지 않는 조건
	
	**우선순위**
	() -> NOT -> AND -> OR 

--ORDER BY 는 WHERE 절 뒤에 쓴다.

컬럼 별칭 설정
	SELECT 컬럼명 AS "별칭"
	SELECT 컬럼명  "별칭"
	SELECT 컬럼명 AS 별칭
	SELECT 컬럼명 별칭	
	SELECT 컬럼명 "별칭" **(별칭이 키워드이거나 띄어쓰기가 있으면 쌍따옴표 생략 불가)**
	...
	별칭은 WHERE 절 사용 불가, ORDER BY 절 사용 가능

컴파일 순서



